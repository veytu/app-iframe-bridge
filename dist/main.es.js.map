{"version":3,"file":"main.es.js","sources":["../../../node_modules/.pnpm/side-effect-manager@1.2.1/node_modules/side-effect-manager/dist/side-effect-manager.es.js","../../app-shared/src/ensure-attributes.ts","../../../node_modules/.pnpm/emittery@0.10.1/node_modules/emittery/index.js","../src/page.ts","../src/hardcode.ts","../src/typings.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["const SOUP = \"!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst SOUP_LEN = 87;\nconst ID_LEN = 20;\nconst reusedIdCarrier = [];\nconst genUID = () => {\n  for (let i = 0; i < ID_LEN; i++) {\n    reusedIdCarrier[i] = SOUP.charAt(Math.random() * SOUP_LEN);\n  }\n  return reusedIdCarrier.join(\"\");\n};\nfunction invoke(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    console.error(e);\n  }\n}\nclass SideEffectManager {\n  constructor() {\n    this.push = this.addDisposer;\n    this.disposers = new Map();\n  }\n  addDisposer(disposer, disposerID = this.genUID()) {\n    this.flush(disposerID);\n    this.disposers.set(disposerID, Array.isArray(disposer) ? joinDisposers(disposer) : disposer);\n    return disposerID;\n  }\n  add(executor, disposerID = this.genUID()) {\n    const disposers = executor();\n    return disposers ? this.addDisposer(disposers, disposerID) : disposerID;\n  }\n  addEventListener(el, type, listener, options, disposerID = this.genUID()) {\n    el.addEventListener(type, listener, options);\n    this.addDisposer(() => el.removeEventListener(type, listener, options), disposerID);\n    return disposerID;\n  }\n  setTimeout(handler, timeout, disposerID = this.genUID()) {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposerID);\n      handler();\n    }, timeout);\n    return this.addDisposer(() => window.clearTimeout(ticket), disposerID);\n  }\n  setInterval(handler, timeout, disposerID = this.genUID()) {\n    const ticket = window.setInterval(handler, timeout);\n    return this.addDisposer(() => window.clearInterval(ticket), disposerID);\n  }\n  remove(disposerID) {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n  flush(disposerID) {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      disposer();\n    }\n  }\n  flushAll() {\n    this.disposers.forEach(invoke);\n    this.disposers.clear();\n  }\n  genUID() {\n    let uid;\n    do {\n      uid = genUID();\n    } while (this.disposers.has(uid));\n    return uid;\n  }\n}\nfunction joinDisposers(disposers) {\n  return () => disposers.forEach(invoke);\n}\nclass AsyncSideEffectManager {\n  constructor() {\n    this.push = this.addDisposer;\n    this.finished = Promise.resolve();\n    this.disposers = new Map();\n    this._nextTask = new Map();\n    this._isRunning = new Set();\n  }\n  add(executor, disposerID = this.genUID()) {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._add(executor, disposerID));\n    } else {\n      this._add(executor, disposerID);\n    }\n    return disposerID;\n  }\n  async _add(executor, disposerID) {\n    this._startTask(disposerID);\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    try {\n      const disposers = await executor();\n      if (disposers) {\n        this.disposers.set(disposerID, Array.isArray(disposers) ? joinAsyncDisposers(disposers) : disposers);\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    this._endTask(disposerID);\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n  addDisposer(disposer, disposerID = this.genUID()) {\n    return this.add(() => disposer, disposerID);\n  }\n  remove(disposerID) {\n    const disposer = this.disposers.get(disposerID);\n    this.disposers.delete(disposerID);\n    return disposer;\n  }\n  flush(disposerID) {\n    if (this._isRunning.has(disposerID)) {\n      this._nextTask.set(disposerID, () => this._flush(disposerID));\n    } else {\n      this._flush(disposerID);\n    }\n  }\n  async _flush(disposerID) {\n    const disposer = this.remove(disposerID);\n    if (disposer) {\n      this._startTask(disposerID);\n      try {\n        await disposer();\n      } catch (e) {\n        console.error(e);\n      }\n      this._endTask(disposerID);\n    }\n    const task = this._nextTask.get(disposerID);\n    if (task) {\n      this._nextTask.delete(disposerID);\n      task();\n    }\n  }\n  flushAll() {\n    this.disposers.forEach((_, disposerID) => this.flush(disposerID));\n  }\n  genUID() {\n    let uid;\n    do {\n      uid = genUID();\n    } while (this.disposers.has(uid));\n    return uid;\n  }\n  _startTask(disposerID) {\n    this._isRunning.add(disposerID);\n    if (!this._resolveFinished) {\n      this.finished = new Promise((resolve) => {\n        this._resolveFinished = resolve;\n      });\n    }\n  }\n  _endTask(disposerID) {\n    this._isRunning.delete(disposerID);\n    if (this._resolveFinished && this._isRunning.size <= 0 && this._nextTask.size <= 0) {\n      this._resolveFinished();\n      this._resolveFinished = void 0;\n    }\n  }\n}\nfunction joinAsyncDisposers(disposers) {\n  return () => Promise.all(disposers.map(invoke));\n}\nclass Disposable {\n  constructor() {\n    this.push = this.addDisposer;\n    this.disposers = new Set();\n  }\n  addDisposer(disposers) {\n    if (Array.isArray(disposers)) {\n      disposers.forEach((disposer) => {\n        this.disposers.add(disposer);\n      });\n    } else {\n      this.disposers.add(disposers);\n    }\n  }\n  add(executor) {\n    const disposers = executor();\n    if (disposers) {\n      this.push(disposers);\n    }\n  }\n  addEventListener(el, type, listener, options) {\n    el.addEventListener(type, listener, options);\n    const disposer = () => el.removeEventListener(type, listener, options);\n    this.push(disposer);\n    return disposer;\n  }\n  setTimeout(handler, timeout) {\n    const ticket = window.setTimeout(() => {\n      this.remove(disposer);\n      handler();\n    }, timeout);\n    const disposer = () => window.clearTimeout(ticket);\n    this.push(disposer);\n    return disposer;\n  }\n  setInterval(handler, timeout) {\n    const ticket = setInterval(handler, timeout);\n    const disposer = () => clearInterval(ticket);\n    this.push(disposer);\n    return disposer;\n  }\n  remove(disposer) {\n    this.disposers.delete(disposer);\n  }\n  flush(disposer) {\n    this.remove(disposer);\n    disposer();\n  }\n  flushAll() {\n    this.disposers.forEach(invoke);\n    this.disposers.clear();\n  }\n}\nexport { AsyncSideEffectManager, Disposable, SideEffectManager, genUID, joinAsyncDisposers, joinDisposers };\n//# sourceMappingURL=side-effect-manager.es.js.map\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { AppContext } from \"@netless/window-manager\";\n\nfunction isObject(val: unknown): val is Record<string, unknown> {\n  return val != null && typeof val === \"object\" && !Array.isArray(val);\n}\n\nexport interface Attributes {\n  [key: string]: any;\n}\n\nexport function ensureAttributes<T extends Attributes>(context: AppContext<T>, initAttrs: T): T {\n  let attrs = context.getAttributes();\n  if (!attrs) {\n    context.setAttributes(initAttrs);\n    attrs = context.getAttributes();\n  }\n  if (!attrs) {\n    throw new Error(\"[NetlessAppMonaco] No attributes\");\n  }\n  if (isObject(initAttrs)) {\n    Object.keys(initAttrs).forEach(key => {\n      if (!Object.prototype.hasOwnProperty.call(attrs, key)) {\n        context.updateAttributes([key], initAttrs[key] as {});\n      }\n    });\n  }\n  return attrs;\n}\n","'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst producersMap = new WeakMap();\nconst anyProducer = Symbol('anyProducer');\nconst resolvedPromise = Promise.resolve();\n\nconst listenerAdded = Symbol('listenerAdded');\nconst listenerRemoved = Symbol('listenerRemoved');\n\nlet isGlobalDebugEnabled = false;\n\nfunction assertEventName(eventName) {\n\tif (typeof eventName !== 'string' && typeof eventName !== 'symbol') {\n\t\tthrow new TypeError('eventName must be a string or a symbol');\n\t}\n}\n\nfunction assertListener(listener) {\n\tif (typeof listener !== 'function') {\n\t\tthrow new TypeError('listener must be a function');\n\t}\n}\n\nfunction getListeners(instance, eventName) {\n\tconst events = eventsMap.get(instance);\n\tif (!events.has(eventName)) {\n\t\tevents.set(eventName, new Set());\n\t}\n\n\treturn events.get(eventName);\n}\n\nfunction getEventProducers(instance, eventName) {\n\tconst key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;\n\tconst producers = producersMap.get(instance);\n\tif (!producers.has(key)) {\n\t\tproducers.set(key, new Set());\n\t}\n\n\treturn producers.get(key);\n}\n\nfunction enqueueProducers(instance, eventName, eventData) {\n\tconst producers = producersMap.get(instance);\n\tif (producers.has(eventName)) {\n\t\tfor (const producer of producers.get(eventName)) {\n\t\t\tproducer.enqueue(eventData);\n\t\t}\n\t}\n\n\tif (producers.has(anyProducer)) {\n\t\tconst item = Promise.all([eventName, eventData]);\n\t\tfor (const producer of producers.get(anyProducer)) {\n\t\t\tproducer.enqueue(item);\n\t\t}\n\t}\n}\n\nfunction iterator(instance, eventNames) {\n\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\tlet isFinished = false;\n\tlet flush = () => {};\n\tlet queue = [];\n\n\tconst producer = {\n\t\tenqueue(item) {\n\t\t\tqueue.push(item);\n\t\t\tflush();\n\t\t},\n\t\tfinish() {\n\t\t\tisFinished = true;\n\t\t\tflush();\n\t\t}\n\t};\n\n\tfor (const eventName of eventNames) {\n\t\tgetEventProducers(instance, eventName).add(producer);\n\t}\n\n\treturn {\n\t\tasync next() {\n\t\t\tif (!queue) {\n\t\t\t\treturn {done: true};\n\t\t\t}\n\n\t\t\tif (queue.length === 0) {\n\t\t\t\tif (isFinished) {\n\t\t\t\t\tqueue = undefined;\n\t\t\t\t\treturn this.next();\n\t\t\t\t}\n\n\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\tflush = resolve;\n\t\t\t\t});\n\n\t\t\t\treturn this.next();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: await queue.shift()\n\t\t\t};\n\t\t},\n\n\t\tasync return(value) {\n\t\t\tqueue = undefined;\n\n\t\t\tfor (const eventName of eventNames) {\n\t\t\t\tgetEventProducers(instance, eventName).delete(producer);\n\t\t\t}\n\n\t\t\tflush();\n\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\t{done: true, value: await value} :\n\t\t\t\t{done: true};\n\t\t},\n\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\nfunction defaultMethodNamesOrAssert(methodNames) {\n\tif (methodNames === undefined) {\n\t\treturn allEmitteryMethods;\n\t}\n\n\tif (!Array.isArray(methodNames)) {\n\t\tthrow new TypeError('`methodNames` must be an array of strings');\n\t}\n\n\tfor (const methodName of methodNames) {\n\t\tif (!allEmitteryMethods.includes(methodName)) {\n\t\t\tif (typeof methodName !== 'string') {\n\t\t\t\tthrow new TypeError('`methodNames` element must be a string');\n\t\t\t}\n\n\t\t\tthrow new Error(`${methodName} is not Emittery method`);\n\t\t}\n\t}\n\n\treturn methodNames;\n}\n\nconst isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;\n\nclass Emittery {\n\tstatic mixin(emitteryPropertyName, methodNames) {\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\t\treturn target => {\n\t\t\tif (typeof target !== 'function') {\n\t\t\t\tthrow new TypeError('`target` must be function');\n\t\t\t}\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tif (target.prototype[methodName] !== undefined) {\n\t\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getEmitteryProperty() {\n\t\t\t\tObject.defineProperty(this, emitteryPropertyName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: new Emittery()\n\t\t\t\t});\n\t\t\t\treturn this[emitteryPropertyName];\n\t\t\t}\n\n\t\t\tObject.defineProperty(target.prototype, emitteryPropertyName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tget: getEmitteryProperty\n\t\t\t});\n\n\t\t\tconst emitteryMethodCaller = methodName => function (...args) {\n\t\t\t\treturn this[emitteryPropertyName][methodName](...args);\n\t\t\t};\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tObject.defineProperty(target.prototype, methodName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: emitteryMethodCaller(methodName)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn target;\n\t\t};\n\t}\n\n\tstatic get isDebugEnabled() {\n\t\tif (typeof process !== 'object') {\n\t\t\treturn isGlobalDebugEnabled;\n\t\t}\n\n\t\tconst {env} = process || {env: {}};\n\t\treturn env.DEBUG === 'emittery' || env.DEBUG === '*' || isGlobalDebugEnabled;\n\t}\n\n\tstatic set isDebugEnabled(newValue) {\n\t\tisGlobalDebugEnabled = newValue;\n\t}\n\n\tconstructor(options = {}) {\n\t\tanyMap.set(this, new Set());\n\t\teventsMap.set(this, new Map());\n\t\tproducersMap.set(this, new Map());\n\t\tthis.debug = options.debug || {};\n\n\t\tif (this.debug.enabled === undefined) {\n\t\t\tthis.debug.enabled = false;\n\t\t}\n\n\t\tif (!this.debug.logger) {\n\t\t\tthis.debug.logger = (type, debugName, eventName, eventData) => {\n\t\t\t\teventData = JSON.stringify(eventData);\n\n\t\t\t\tif (typeof eventName === 'symbol') {\n\t\t\t\t\teventName = eventName.toString();\n\t\t\t\t}\n\n\t\t\t\tconst currentTime = new Date();\n\t\t\t\tconst logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;\n\t\t\t\tconsole.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}\\n\\tdata: ${eventData}`);\n\t\t\t};\n\t\t}\n\t}\n\n\tlogIfDebugEnabled(type, eventName, eventData) {\n\t\tif (Emittery.isDebugEnabled || this.debug.enabled) {\n\t\t\tthis.debug.logger(type, this.debug.name, eventName, eventData);\n\t\t}\n\t}\n\n\ton(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).add(listener);\n\n\t\t\tthis.logIfDebugEnabled('subscribe', eventName, undefined);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerAdded, {eventName, listener});\n\t\t\t}\n\t\t}\n\n\t\treturn this.off.bind(this, eventNames, listener);\n\t}\n\n\toff(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).delete(listener);\n\n\t\t\tthis.logIfDebugEnabled('unsubscribe', eventName, undefined);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerRemoved, {eventName, listener});\n\t\t\t}\n\t\t}\n\t}\n\n\tonce(eventNames) {\n\t\treturn new Promise(resolve => {\n\t\t\tconst off = this.on(eventNames, data => {\n\t\t\t\toff();\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\tevents(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t}\n\n\t\treturn iterator(this, eventNames);\n\t}\n\n\tasync emit(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tthis.logIfDebugEnabled('emit', eventName, eventData);\n\n\t\tenqueueProducers(this, eventName, eventData);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\tawait Promise.all([\n\t\t\t...staticListeners.map(async listener => {\n\t\t\t\tif (listeners.has(listener)) {\n\t\t\t\t\treturn listener(eventData);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t...staticAnyListeners.map(async listener => {\n\t\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\t\treturn listener(eventName, eventData);\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t}\n\n\tasync emitSerial(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tthis.logIfDebugEnabled('emitSerial', eventName, eventData);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\t/* eslint-disable no-await-in-loop */\n\t\tfor (const listener of staticListeners) {\n\t\t\tif (listeners.has(listener)) {\n\t\t\t\tawait listener(eventData);\n\t\t\t}\n\t\t}\n\n\t\tfor (const listener of staticAnyListeners) {\n\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\tawait listener(eventName, eventData);\n\t\t\t}\n\t\t}\n\t\t/* eslint-enable no-await-in-loop */\n\t}\n\n\tonAny(listener) {\n\t\tassertListener(listener);\n\n\t\tthis.logIfDebugEnabled('subscribeAny', undefined, undefined);\n\n\t\tanyMap.get(this).add(listener);\n\t\tthis.emit(listenerAdded, {listener});\n\t\treturn this.offAny.bind(this, listener);\n\t}\n\n\tanyEvent() {\n\t\treturn iterator(this);\n\t}\n\n\toffAny(listener) {\n\t\tassertListener(listener);\n\n\t\tthis.logIfDebugEnabled('unsubscribeAny', undefined, undefined);\n\n\t\tthis.emit(listenerRemoved, {listener});\n\t\tanyMap.get(this).delete(listener);\n\t}\n\n\tclearListeners(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tthis.logIfDebugEnabled('clear', eventName, undefined);\n\n\t\t\tif (typeof eventName === 'string' || typeof eventName === 'symbol') {\n\t\t\t\tgetListeners(this, eventName).clear();\n\n\t\t\t\tconst producers = getEventProducers(this, eventName);\n\n\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\tproducer.finish();\n\t\t\t\t}\n\n\t\t\t\tproducers.clear();\n\t\t\t} else {\n\t\t\t\tanyMap.get(this).clear();\n\n\t\t\t\tfor (const listeners of eventsMap.get(this).values()) {\n\t\t\t\t\tlisteners.clear();\n\t\t\t\t}\n\n\t\t\t\tfor (const producers of producersMap.get(this).values()) {\n\t\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\t\tproducer.finish();\n\t\t\t\t\t}\n\n\t\t\t\t\tproducers.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlistenerCount(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tlet count = 0;\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tif (typeof eventName === 'string') {\n\t\t\t\tcount += anyMap.get(this).size + getListeners(this, eventName).size +\n\t\t\t\t\tgetEventProducers(this, eventName).size + getEventProducers(this).size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof eventName !== 'undefined') {\n\t\t\t\tassertEventName(eventName);\n\t\t\t}\n\n\t\t\tcount += anyMap.get(this).size;\n\n\t\t\tfor (const value of eventsMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\n\t\t\tfor (const value of producersMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tbindMethods(target, methodNames) {\n\t\tif (typeof target !== 'object' || target === null) {\n\t\t\tthrow new TypeError('`target` must be an object');\n\t\t}\n\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\n\t\tfor (const methodName of methodNames) {\n\t\t\tif (target[methodName] !== undefined) {\n\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t}\n\n\t\t\tObject.defineProperty(target, methodName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: this[methodName].bind(this)\n\t\t\t});\n\t\t}\n\t}\n}\n\nconst allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');\n\nObject.defineProperty(Emittery, 'listenerAdded', {\n\tvalue: listenerAdded,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\nObject.defineProperty(Emittery, 'listenerRemoved', {\n\tvalue: listenerRemoved,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\n\nmodule.exports = Emittery;\n","/**\n\nthe page api for iframe bridge\n\niframe -> me:\n  SetPage(3) // pages = [1,2,3]\n  PageTo(1)  // page = 1\n  PrevPage() // page = Math.max(1, page - 1)\n  NextPage() // page = Math.min(pages.length, page + 1)\n\nme -> iframe:\n  RoomStateChanged(pageEvent(page))\n\n*/\n\nimport type { RoomState } from \"white-web-sdk\";\n\nexport function fakeRoomStateChanged(\n  page: number,\n  maxPage: number,\n  contextPath: string\n): Partial<RoomState> {\n  return {\n    sceneState: {\n      sceneName: `${page}`,\n      scenePath: `${contextPath}/${page}`,\n      contextPath,\n      scenes: pageToScenes(maxPage),\n      index: page - 1,\n    },\n  };\n}\n\nexport function pageToScenes(maxPage: number): { name: string }[] {\n  const scenes = [];\n  for (let page = 1; page <= maxPage; ++page) {\n    scenes.push({ name: String(page) });\n  }\n  return scenes;\n}\n\nexport function prevPage(page: number): number {\n  return Math.max(1, page - 1);\n}\n\nexport function nextPage(page: number, maxPage: number): number {\n  return Math.min(maxPage, page + 1);\n}\n","export const width = 630;\nexport const height = 350;\n","export enum IframeEvents {\n  Init = \"Init\",\n  AttributesUpdate = \"AttributesUpdate\",\n  SetAttributes = \"SetAttributes\",\n  RegisterMagixEvent = \"RegisterMagixEvent\",\n  RemoveMagixEvent = \"RemoveMagixEvent\",\n  RemoveAllMagixEvent = \"RemoveAllMagixEvent\",\n  RoomStateChanged = \"RoomStateChanged\",\n  DispatchMagixEvent = \"DispatchMagixEvent\",\n  ReceiveMagixEvent = \"ReciveMagixEvent\", // the typo is intentional to stay the same\n  NextPage = \"NextPage\",\n  PrevPage = \"PrevPage\",\n  SDKCreate = \"SDKCreate\",\n  OnCreate = \"OnCreate\",\n  SetPage = \"SetPage\",\n  GetAttributes = \"GetAttributes\",\n  Ready = \"Ready\",\n  Destroy = \"Destory\", // the typo is intentional to stay the same\n  StartCreate = \"StartCreate\",\n  WrapperDidUpdate = \"WrapperDidUpdate\",\n  DisplayIframe = \"DisplayIframe\",\n  HideIframe = \"HideIframe\", // will never emit\n  PageTo = \"PageTo\",\n}\n\nexport enum DomEvents {\n  WrapperDidMount = \"WrapperDidMount\",\n  IframeLoad = \"IframeLoad\",\n}\n","import type { AppContext } from \"@netless/window-manager\";\n\nexport interface UserPayload {\n  memberId: number;\n  uid: string;\n  userId: string;\n  nickName: string;\n  cursorName: string;\n}\n\nexport function getUserPayload(context: AppContext): UserPayload {\n  const room = context.getRoom();\n  const displayer = context.getDisplayer();\n  const memberId = displayer.observerId;\n  const userPayload = displayer.state.roomMembers.find(\n    member => member.memberId === memberId\n  )?.payload;\n  const uid = userPayload?.uid || room?.uid || \"\";\n  const nickName = userPayload?.nickName || uid;\n  const userId = userPayload?.userId || uid;\n  const cursorName = userPayload?.cursorName || nickName || \"\";\n  return { memberId, uid, userId, nickName, cursorName };\n}\n\n// from @polka/url (https://github.com/lukeed/polka, MIT license)\nexport function parse(url: string) {\n  const index = url.indexOf(\"?\", 1);\n  if (index !== -1) {\n    return {\n      search: url.slice(index),\n      pathname: url.slice(0, index),\n    };\n  }\n  return {\n    search: \"\",\n    pathname: url,\n  };\n}\n\nexport function appendQuery(url: string, query: string) {\n  const { pathname, search } = parse(url);\n  return pathname + (search ? `${search}&` : \"?\") + query;\n}\n\nexport function element<T extends keyof HTMLElementTagNameMap>(tag: T) {\n  return document.createElement(tag);\n}\n\nexport function attr(el: HTMLElement, key: string, value: string | null) {\n  if (value == null) {\n    el.removeAttribute(key);\n  } else {\n    el.setAttribute(key, value);\n  }\n}\n\nexport function append(el: HTMLElement, node: HTMLElement) {\n  return el.appendChild(node);\n}\n\nexport function detach(el: HTMLElement) {\n  return el.parentNode?.removeChild(el);\n}\n\nexport function noop() {\n  // noop\n}\n\nexport const nextTick = /* @__PURE__ */ Promise.resolve();\n\nexport function writable<T>(value: T) {\n  const listeners: Array<(value: T) => void> = [];\n\n  return {\n    get value() {\n      return value;\n    },\n    set(newValue: T) {\n      value = newValue;\n      listeners.forEach(listener => listener(value));\n    },\n    subscribe(listener: (value: T) => void) {\n      listeners.push(listener);\n      nextTick.then(() => listener(value));\n      return () => {\n        listeners.splice(listeners.indexOf(listener), 1);\n      };\n    },\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ensureAttributes } from \"@netless/app-shared\";\nimport type { NetlessApp } from \"@netless/window-manager\";\nimport Emittery from \"emittery\";\nimport { SideEffectManager } from \"side-effect-manager\";\nimport type { AnimationMode, ApplianceNames, Event, RoomState } from \"white-web-sdk\";\nimport { fakeRoomStateChanged, nextPage, pageToScenes, prevPage } from \"./page\";\nimport { height } from \"./hardcode\";\nimport { DomEvents, IframeEvents } from \"./typings\";\nimport { getUserPayload } from \"./utils\";\n\nexport interface Attributes {\n  src: string;\n  displaySceneDir: string;\n  lastEvent: { name: string; payload: unknown } | null;\n  state: Record<string, unknown>;\n  page: number;\n  maxPage: number;\n  uid?: string | null;\n}\n\nconst ClickThroughAppliances = new Set([\"clicker\", \"selector\"]);\n\nconst IframeBridge: NetlessApp<Attributes> = {\n  kind: \"IframeBridge\",\n  setup(context) {\n    const box = context.getBox();\n    const view = context.getView();\n    const displayer = context.getDisplayer();\n    const room = context.getRoom();\n    const { uid } = getUserPayload(context);\n\n    const attrs = ensureAttributes(context, {\n      src: \"about:blank\",\n      displaySceneDir: \"/h5\",\n      lastEvent: null,\n      state: {},\n      page: 0,\n      maxPage: 0,\n    });\n\n    const sideEffectManager = new SideEffectManager();\n\n    const container = document.createElement(\"div\");\n    Object.assign(container.style, { width: \"100%\", height: \"100%\", position: \"relative\" });\n\n    const iframe = document.createElement(\"iframe\");\n    Object.assign(iframe.style, {\n      width: \"100%\",\n      height: \"100%\",\n      border: \"none\",\n      display: \"block\",\n    });\n    container.appendChild(iframe);\n\n    const role = context.storage.state.uid === uid ? 0 : 2;\n    if (role == 0) {\n      const closeBtn = document.createElement(\"button\");\n      Object.assign(closeBtn.style, {\n        position: \"absolute\",\n        right: \"10px\",\n        top: \"10px\",\n        zIndex: 1000,\n        background: \"white\",\n        border: \"none\",\n        borderRadius: \"100%\",\n        width: \"30px\",\n        height: \"30px\",\n        boxShadow: \"0 20px 25px -5px #0000001a, 0 8px 10px -6px #0000001a\",\n      });\n      closeBtn.innerHTML = \"X\";\n      container.appendChild(closeBtn);\n      closeBtn.onclick = function (e: MouseEvent) {\n        e.preventDefault();\n        e.stopPropagation();\n        box._delegateEvents.emit(\"close\");\n      };\n    }\n\n    box.mountContent(container);\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    let toggleClickThrough: (enable?: boolean) => void = () => {};\n    const shouldClickThrough = (tool?: ApplianceNames) => {\n      return ClickThroughAppliances.has(tool as ApplianceNames);\n    };\n\n    if (view) {\n      const viewBox = document.createElement(\"div\");\n      Object.assign(viewBox.style, {\n        width: \"100%\",\n        height: \"100%\",\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        overflow: \"hidden\",\n      });\n      container.appendChild(viewBox);\n      context.mountView(viewBox);\n\n      view.disableCameraTransform = true;\n      sideEffectManager.add(() => {\n        const onResize = () => {\n          const clientRect = container.getBoundingClientRect();\n          const scale = clientRect.height / height;\n          view.moveCamera({ scale, animationMode: \"immediately\" as AnimationMode });\n        };\n        const observer = new ResizeObserver(onResize);\n        observer.observe(container);\n        return () => observer.disconnect();\n      });\n\n      toggleClickThrough = (enable?: boolean) => {\n        viewBox.style.pointerEvents = enable ? \"none\" : \"auto\";\n      };\n\n      toggleClickThrough(shouldClickThrough(room?.state.memberState.currentApplianceName));\n    }\n\n    const withReadonlyAttributes = (state: Record<string, unknown>) => ({\n      ...state,\n      // for backward compatibility\n      url: attrs.src,\n      displaySceneDir: attrs.displaySceneDir,\n      width: iframe.scrollWidth,\n      height: iframe.scrollHeight,\n      useClicker: true,\n      lastEvent: attrs.lastEvent,\n    });\n\n    const emitter = new Emittery<Record<IframeEvents | DomEvents, any>>();\n    const magixEventMap = new Map<string, (event: Event) => void>();\n\n    const removeAllMagixEvent = () => {\n      magixEventMap.forEach((listener, event) => {\n        displayer.removeMagixEventListener(event, listener);\n      });\n      magixEventMap.clear();\n    };\n\n    const log = (...args: any) => import.meta.env.DEV && console.log(...args);\n\n    const postMessage = (message: { kind: IframeEvents; payload: any }) => {\n      log(\"[IframeBridge] postMessage %s %O\", message.kind, message.payload);\n      iframe.contentWindow?.postMessage(JSON.parse(JSON.stringify(message)), \"*\");\n    };\n\n    const dispatchMagixEvent = (event: string, payload: any) => {\n      if (context.getIsWritable()) {\n        context.updateAttributes([\"lastEvent\"], { name: event, payload });\n        log(\"[IframeBridge] dispatchMagixEvent %s %O\", event, payload);\n        room?.dispatchMagixEvent(event, payload);\n      }\n    };\n\n    const sendInitMessage = () => {\n      postMessage({\n        kind: IframeEvents.Init,\n        payload: {\n          attributes: withReadonlyAttributes(attrs.state),\n          roomState: displayer.state,\n          currentPage: attrs.page,\n          observerId: displayer.observerId,\n        },\n      });\n    };\n\n    let hackCocos = attrs.src.includes(\"cocos\");\n\n    const onLoad = (ev: globalThis.Event): void => {\n      sendInitMessage();\n      emitter.emit(DomEvents.IframeLoad, ev);\n      emitter.on(IframeEvents.Ready, () => {\n        if (attrs.lastEvent?.payload) {\n          postMessage(attrs.lastEvent?.payload as { kind: IframeEvents; payload: any });\n        }\n      });\n      if (hackCocos) {\n        setTimeout(() => {\n          postMessage({\n            kind: IframeEvents.RoomStateChanged,\n            payload: fakeRoomStateChanged(1, attrs.maxPage, attrs.displaySceneDir),\n          });\n        }, 500);\n        hackCocos = false;\n      }\n      iframe.removeEventListener(\"load\", onLoad);\n    };\n    sideEffectManager.addEventListener(iframe, \"load\", onLoad);\n\n    let retryCount = 0;\n    const onError = (): void => {\n      // try again\n      if (retryCount++ < 3) {\n        iframe.src = attrs.src;\n      }\n    };\n    sideEffectManager.addEventListener(iframe, \"error\", onError);\n\n    iframe.src = attrs.src;\n\n    sideEffectManager.add(() =>\n      context.mobxUtils.autorun(() => {\n        postMessage({\n          kind: IframeEvents.AttributesUpdate,\n          payload: withReadonlyAttributes(attrs.state),\n        });\n      })\n    );\n    sideEffectManager.add(() =>\n      context.mobxUtils.autorun(() => {\n        iframe.src = attrs.src;\n      })\n    );\n\n    sideEffectManager.add(() =>\n      context.mobxUtils.autorun(() => {\n        postMessage({\n          kind: IframeEvents.RoomStateChanged,\n          payload: fakeRoomStateChanged(attrs.page, attrs.maxPage, attrs.displaySceneDir),\n        });\n      })\n    );\n\n    const bridge = {\n      emitter,\n      postMessage,\n      context,\n    };\n\n    emitter.emit(IframeEvents.StartCreate);\n    emitter.emit(IframeEvents.OnCreate, bridge);\n\n    if (room) {\n      sideEffectManager.add(() => {\n        const onRoomStateChanged = (e: Partial<RoomState>) => {\n          if (e.memberState) {\n            toggleClickThrough(shouldClickThrough(e.memberState.currentApplianceName));\n          }\n        };\n        room.callbacks.on(\"onRoomStateChanged\", onRoomStateChanged);\n        return () => room.callbacks.off(\"onRoomStateChanged\", onRoomStateChanged);\n      });\n    }\n\n    sideEffectManager.addEventListener(window, \"message\", (ev: MessageEvent) => {\n      if (ev.source !== iframe.contentWindow) {\n        return;\n      }\n      const data: { kind: IframeEvents; payload: any } = ev.data;\n      log(\"[IframeBridge] received\", data.kind, data.payload);\n      switch (data.kind) {\n        case IframeEvents.SetAttributes: {\n          context.updateAttributes([\"state\"], { ...attrs.state, ...data.payload });\n          break;\n        }\n        case IframeEvents.RegisterMagixEvent: {\n          const listener = (ev: Event) => {\n            if (ev.authorId === displayer.observerId) {\n              return;\n            }\n            postMessage({ kind: IframeEvents.ReceiveMagixEvent, payload: ev });\n          };\n          const eventName = data.payload;\n          magixEventMap.set(eventName, listener);\n          displayer.addMagixEventListener(eventName, listener);\n          break;\n        }\n        case IframeEvents.RemoveMagixEvent: {\n          const eventName = data.payload;\n          const listener = magixEventMap.get(eventName);\n          displayer.removeMagixEventListener(eventName, listener);\n          break;\n        }\n        case IframeEvents.DispatchMagixEvent: {\n          const ev: { event: string; payload: any } = data.payload;\n          dispatchMagixEvent(ev.event, ev.payload);\n          break;\n        }\n        case IframeEvents.RemoveAllMagixEvent: {\n          removeAllMagixEvent();\n          break;\n        }\n        case IframeEvents.NextPage: {\n          if (context.getIsWritable() && room) {\n            const page = nextPage(attrs.page, attrs.maxPage);\n            if (page === attrs.page) break;\n            context.setScenePath([attrs.displaySceneDir, page].join(\"/\"));\n            context.updateAttributes([\"page\"], page);\n            dispatchMagixEvent(IframeEvents.NextPage, {});\n          }\n          break;\n        }\n        case IframeEvents.PrevPage: {\n          if (context.getIsWritable() && room) {\n            const page = prevPage(attrs.page);\n            if (page === attrs.page) break;\n            context.setScenePath([attrs.displaySceneDir, page].join(\"/\"));\n            context.updateAttributes([\"page\"], page);\n            dispatchMagixEvent(IframeEvents.PrevPage, {});\n          }\n          break;\n        }\n        case IframeEvents.SetPage: {\n          const maxPage = Number(data.payload) || 0;\n          if (context.getIsWritable() && room) {\n            if (!maxPage) {\n              room.removeScenes(attrs.displaySceneDir);\n            } else {\n              const scenes = room.entireScenes()[attrs.displaySceneDir];\n              if (!scenes || scenes.length !== maxPage) {\n                room.removeScenes(attrs.displaySceneDir);\n                room.putScenes(attrs.displaySceneDir, pageToScenes(maxPage));\n              }\n              context.setScenePath(`${attrs.displaySceneDir}/1`);\n              log(\"[IframeBridge] SetPage\", maxPage);\n              context.updateAttributes([\"maxPage\"], maxPage);\n            }\n          }\n          break;\n        }\n        case IframeEvents.PageTo: {\n          const page = data.payload as number;\n          if (context.getIsWritable() && room) {\n            if (!Number.isSafeInteger(page) || page <= 0) break;\n            context.setScenePath(`${attrs.displaySceneDir}/${page}`);\n            context.updateAttributes([\"page\"], page);\n            dispatchMagixEvent(IframeEvents.PageTo, page - 1);\n          }\n          break;\n        }\n        case IframeEvents.SDKCreate: {\n          sendInitMessage();\n          break;\n        }\n        case IframeEvents.GetAttributes: {\n          postMessage({\n            kind: IframeEvents.GetAttributes,\n            payload: withReadonlyAttributes(attrs.state),\n          });\n          break;\n        }\n        default: {\n          console.warn(`[IframeBridge]: unknown event kind \"${data.kind}\"`);\n        }\n      }\n    });\n\n    context.emitter.on(\"destroy\", () => {\n      console.log(\"[IframeBridge]: destroy\");\n      emitter.emit(IframeEvents.Destroy);\n      sideEffectManager.flushAll();\n      removeAllMagixEvent();\n      iframe.remove();\n    });\n\n    if (import.meta.env.DEV) {\n      (window as any).iframeBridge = bridge;\n    }\n\n    return bridge;\n  },\n};\n\nexport default IframeBridge;\n"],"names":["Emittery"],"mappings":"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"}